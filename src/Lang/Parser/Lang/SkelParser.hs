-- File generated by the BNF Converter (bnfc 2.9.4).

-- Templates for pattern matching on abstract syntax

{-# OPTIONS_GHC -fno-warn-unused-matches #-}

module Lang.SkelParser where

import Prelude (($), Either(..), String, (++), Show, show)
import qualified Lang.AbsParser

type Err = Either String
type Result = Err String

failure :: Show a => a -> Result
failure x = Left $ "Undefined case: " ++ show x

transTokUnit :: Lang.AbsParser.TokUnit -> Result
transTokUnit x = case x of
  Lang.AbsParser.TokUnit string -> failure x

transUIdent :: Lang.AbsParser.UIdent -> Result
transUIdent x = case x of
  Lang.AbsParser.UIdent string -> failure x

transPIdent :: Lang.AbsParser.PIdent -> Result
transPIdent x = case x of
  Lang.AbsParser.PIdent string -> failure x

transPInteger :: Lang.AbsParser.PInteger -> Result
transPInteger x = case x of
  Lang.AbsParser.PInteger string -> failure x

transSCPL :: Lang.AbsParser.SCPL -> Result
transSCPL x = case x of
  Lang.AbsParser.SCPLPROG defns -> failure x

transDefn :: Lang.AbsParser.Defn -> Result
transDefn x = case x of
  Lang.AbsParser.DEFN pident stmt -> failure x

transStmt :: Lang.AbsParser.Stmt -> Result
transStmt x = case x of
  Lang.AbsParser.CASESTMT exp caseterms -> failure x
  Lang.AbsParser.IFSTMT exp stmt1 stmt2 -> failure x
  Lang.AbsParser.BARESTMT exp -> failure x
  Lang.AbsParser.ELet let_ letinstmt stmt -> failure x

transLet :: Lang.AbsParser.Let -> Result
transLet x = case x of
  Lang.AbsParser.LET -> failure x
  Lang.AbsParser.LRec -> failure x

transCaseTerm :: Lang.AbsParser.CaseTerm -> Result
transCaseTerm x = case x of
  Lang.AbsParser.CASE_STMT casepattern stmt -> failure x

transLetInStmt :: Lang.AbsParser.LetInStmt -> Result
transLetInStmt x = case x of
  Lang.AbsParser.LET_IN_STMT pident exp -> failure x

transType :: Lang.AbsParser.Type -> Result
transType x = case x of
  Lang.AbsParser.TYPEARROW typen type_ -> failure x
  Lang.AbsParser.TYPENext typen -> failure x

transTypeN :: Lang.AbsParser.TypeN -> Result
transTypeN x = case x of
  Lang.AbsParser.TYPEUNIT tokunit -> failure x
  Lang.AbsParser.TYPECONST_VAR uident -> failure x
  Lang.AbsParser.TYPELIST type_ -> failure x
  Lang.AbsParser.TYPEPROD types -> failure x
  Lang.AbsParser.TYPEBRACKET type_ -> failure x
  Lang.AbsParser.CONST_TYPE constanttype -> failure x

transCasePattern :: Lang.AbsParser.CasePattern -> Result
transCasePattern x = case x of
  Lang.AbsParser.TRUE_PATTERN -> failure x
  Lang.AbsParser.FALSE_PATTERN -> failure x

transExp :: Lang.AbsParser.Exp -> Result
transExp x = case x of
  Lang.AbsParser.EInt pinteger -> failure x
  Lang.AbsParser.ETrue -> failure x
  Lang.AbsParser.EFalse -> failure x
  Lang.AbsParser.EVar pident -> failure x
  Lang.AbsParser.EString string -> failure x
  Lang.AbsParser.EList exps -> failure x
  Lang.AbsParser.ECall pident exps -> failure x
  Lang.AbsParser.ENeg exp -> failure x
  Lang.AbsParser.CONSTERM exp1 exp2 -> failure x
  Lang.AbsParser.EAPPEND exp1 exp2 -> failure x
  Lang.AbsParser.EMul exp1 exp2 -> failure x
  Lang.AbsParser.EDiv exp1 exp2 -> failure x
  Lang.AbsParser.EAdd exp1 exp2 -> failure x
  Lang.AbsParser.ESub exp1 exp2 -> failure x
  Lang.AbsParser.ELt exp1 exp2 -> failure x
  Lang.AbsParser.EGt exp1 exp2 -> failure x
  Lang.AbsParser.ELEq exp1 exp2 -> failure x
  Lang.AbsParser.EGEq exp1 exp2 -> failure x
  Lang.AbsParser.EEq exp1 exp2 -> failure x
  Lang.AbsParser.ENEq exp1 exp2 -> failure x
  Lang.AbsParser.EAnd exp1 exp2 -> failure x
  Lang.AbsParser.EOr exp1 exp2 -> failure x
  Lang.AbsParser.ELambda pidents stmt -> failure x
  Lang.AbsParser.EApp exp1 exp2 -> failure x

transTypeAnnotation :: Lang.AbsParser.TypeAnnotation -> Result
transTypeAnnotation x = case x of
  Lang.AbsParser.TYPEANNOTATION type_ -> failure x
  Lang.AbsParser.TYPEANNOTATION_EMPTY -> failure x

transConstantType :: Lang.AbsParser.ConstantType -> Result
transConstantType x = case x of
  Lang.AbsParser.INTEGER pinteger -> failure x
  Lang.AbsParser.STRING string -> failure x
  Lang.AbsParser.CHAR char -> failure x
  Lang.AbsParser.DOUBLE double -> failure x
