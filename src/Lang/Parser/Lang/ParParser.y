-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module Lang.ParParser
  ( happyError
  , myLexer
  , pSCPL
  , pListDefn
  , pDefn
  , pStmt2
  , pLet
  , pStmt1
  , pCaseTerm
  , pLetInStmt
  , pType
  , pTypeN
  , pListTypeN
  , pListType
  , pListUIdent
  , pCasePattern
  , pListCaseTerm
  , pExp15
  , pExp13
  , pExp12
  , pExp11
  , pExp9
  , pExp8
  , pExp4
  , pExp3
  , pExp1
  , pListPIdent
  , pTypeAnnotation
  , pExp
  , pExp2
  , pExp5
  , pExp6
  , pExp7
  , pExp10
  , pExp14
  , pListExp
  , pConstantType
  ) where

import Prelude

import qualified Lang.AbsParser
import Lang.LexParser

}

%name pSCPL SCPL
%name pListDefn ListDefn
%name pDefn Defn
%name pStmt2 Stmt2
%name pLet Let
%name pStmt1 Stmt1
%name pCaseTerm CaseTerm
%name pLetInStmt LetInStmt
%name pType Type
%name pTypeN TypeN
%name pListTypeN ListTypeN
%name pListType ListType
%name pListUIdent ListUIdent
%name pCasePattern CasePattern
%name pListCaseTerm ListCaseTerm
%name pExp15 Exp15
%name pExp13 Exp13
%name pExp12 Exp12
%name pExp11 Exp11
%name pExp9 Exp9
%name pExp8 Exp8
%name pExp4 Exp4
%name pExp3 Exp3
%name pExp1 Exp1
%name pListPIdent ListPIdent
%name pTypeAnnotation TypeAnnotation
%name pExp Exp
%name pExp2 Exp2
%name pExp5 Exp5
%name pExp6 Exp6
%name pExp7 Exp7
%name pExp10 Exp10
%name pExp14 Exp14
%name pListExp ListExp
%name pConstantType ConstantType
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '!='       { PT _ (TS _ 1)       }
  '&&'       { PT _ (TS _ 2)       }
  '('        { PT _ (TS _ 3)       }
  ')'        { PT _ (TS _ 4)       }
  '*'        { PT _ (TS _ 5)       }
  '+'        { PT _ (TS _ 6)       }
  '++'       { PT _ (TS _ 7)       }
  ','        { PT _ (TS _ 8)       }
  '-'        { PT _ (TS _ 9)       }
  '->'       { PT _ (TS _ 10)      }
  '/'        { PT _ (TS _ 11)      }
  ':'        { PT _ (TS _ 12)      }
  '::'       { PT _ (TS _ 13)      }
  ';'        { PT _ (TS _ 14)      }
  '<'        { PT _ (TS _ 15)      }
  '<='       { PT _ (TS _ 16)      }
  '='        { PT _ (TS _ 17)      }
  '=='       { PT _ (TS _ 18)      }
  '>'        { PT _ (TS _ 19)      }
  '>='       { PT _ (TS _ 20)      }
  'False'    { PT _ (TS _ 21)      }
  'True'     { PT _ (TS _ 22)      }
  '['        { PT _ (TS _ 23)      }
  '\\'       { PT _ (TS _ 24)      }
  ']'        { PT _ (TS _ 25)      }
  'case'     { PT _ (TS _ 26)      }
  'else'     { PT _ (TS _ 27)      }
  'fun'      { PT _ (TS _ 28)      }
  'if'       { PT _ (TS _ 29)      }
  'in'       { PT _ (TS _ 30)      }
  'let'      { PT _ (TS _ 31)      }
  'letrec'   { PT _ (TS _ 32)      }
  'of'       { PT _ (TS _ 33)      }
  'then'     { PT _ (TS _ 34)      }
  '{'        { PT _ (TS _ 35)      }
  '||'       { PT _ (TS _ 36)      }
  '}'        { PT _ (TS _ 37)      }
  L_charac   { PT _ (TC $$)        }
  L_doubl    { PT _ (TD $$)        }
  L_quoted   { PT _ (TL $$)        }
  L_TokUnit  { PT _ (T_TokUnit _)  }
  L_UIdent   { PT _ (T_UIdent _)   }
  L_PIdent   { PT _ (T_PIdent _)   }
  L_PInteger { PT _ (T_PInteger _) }

%%

Char    :: { Char }
Char     : L_charac { (read $1) :: Char }

Double  :: { Double }
Double   : L_doubl  { (read $1) :: Double }

String  :: { String }
String   : L_quoted { $1 }

TokUnit :: { Lang.AbsParser.TokUnit }
TokUnit  : L_TokUnit { Lang.AbsParser.TokUnit (mkPosToken $1) }

UIdent :: { Lang.AbsParser.UIdent }
UIdent  : L_UIdent { Lang.AbsParser.UIdent (mkPosToken $1) }

PIdent :: { Lang.AbsParser.PIdent }
PIdent  : L_PIdent { Lang.AbsParser.PIdent (mkPosToken $1) }

PInteger :: { Lang.AbsParser.PInteger }
PInteger  : L_PInteger { Lang.AbsParser.PInteger (mkPosToken $1) }

SCPL :: { Lang.AbsParser.SCPL }
SCPL : ListDefn { Lang.AbsParser.SCPLPROG $1 }

ListDefn :: { [Lang.AbsParser.Defn] }
ListDefn : Defn { (:[]) $1 } | Defn ListDefn { (:) $1 $2 }

Defn :: { Lang.AbsParser.Defn }
Defn : PIdent '=' Stmt1 { Lang.AbsParser.DEFN $1 $3 }

Stmt2 :: { Lang.AbsParser.Stmt }
Stmt2
  : 'case' Exp 'of' '{' ListCaseTerm '}' { Lang.AbsParser.CASESTMT $2 $5 }
  | 'if' Exp 'then' Stmt2 'else' Stmt2 { Lang.AbsParser.IFSTMT $2 $4 $6 }
  | Exp { Lang.AbsParser.BARESTMT $1 }

Let :: { Lang.AbsParser.Let }
Let
  : 'let' { Lang.AbsParser.LET } | 'letrec' { Lang.AbsParser.LRec }

Stmt1 :: { Lang.AbsParser.Stmt }
Stmt1
  : Let LetInStmt 'in' Stmt1 { Lang.AbsParser.ELet $1 $2 $4 }
  | Stmt2 { $1 }

CaseTerm :: { Lang.AbsParser.CaseTerm }
CaseTerm
  : CasePattern '->' Stmt1 { Lang.AbsParser.CASE_STMT $1 $3 }

LetInStmt :: { Lang.AbsParser.LetInStmt }
LetInStmt : PIdent '=' Exp { Lang.AbsParser.LET_IN_STMT $1 $3 }

Type :: { Lang.AbsParser.Type }
Type
  : TypeN '->' Type { Lang.AbsParser.TYPEARROW $1 $3 }
  | TypeN { Lang.AbsParser.TYPENext $1 }

TypeN :: { Lang.AbsParser.TypeN }
TypeN
  : TokUnit { Lang.AbsParser.TYPEUNIT $1 }
  | UIdent { Lang.AbsParser.TYPECONST_VAR $1 }
  | '[' Type ']' { Lang.AbsParser.TYPELIST $2 }
  | '<' ListType '>' { Lang.AbsParser.TYPEPROD $2 }
  | '(' Type ')' { Lang.AbsParser.TYPEBRACKET $2 }
  | ConstantType { Lang.AbsParser.CONST_TYPE $1 }

ListTypeN :: { [Lang.AbsParser.TypeN] }
ListTypeN
  : {- empty -} { [] }
  | TypeN { (:[]) $1 }
  | TypeN ',' ListTypeN { (:) $1 $3 }

ListType :: { [Lang.AbsParser.Type] }
ListType : Type { (:[]) $1 } | Type ',' ListType { (:) $1 $3 }

ListUIdent :: { [Lang.AbsParser.UIdent] }
ListUIdent
  : {- empty -} { [] }
  | UIdent { (:[]) $1 }
  | UIdent ',' ListUIdent { (:) $1 $3 }

CasePattern :: { Lang.AbsParser.CasePattern }
CasePattern
  : 'True' { Lang.AbsParser.TRUE_PATTERN }
  | 'False' { Lang.AbsParser.FALSE_PATTERN }

ListCaseTerm :: { [Lang.AbsParser.CaseTerm] }
ListCaseTerm
  : CaseTerm { (:[]) $1 } | CaseTerm ';' ListCaseTerm { (:) $1 $3 }

Exp15 :: { Lang.AbsParser.Exp }
Exp15
  : PInteger { Lang.AbsParser.EInt $1 }
  | 'True' { Lang.AbsParser.ETrue }
  | 'False' { Lang.AbsParser.EFalse }
  | PIdent { Lang.AbsParser.EVar $1 }
  | String { Lang.AbsParser.EString $1 }
  | '[' ListExp ']' { Lang.AbsParser.EList $2 }
  | PIdent '(' ListExp ')' { Lang.AbsParser.ECall $1 $3 }
  | '(' Exp ')' { $2 }

Exp13 :: { Lang.AbsParser.Exp }
Exp13
  : '-' Exp14 { Lang.AbsParser.ENeg $2 }
  | Exp13 ':' Exp14 { Lang.AbsParser.CONSTERM $1 $3 }
  | Exp14 { $1 }

Exp12 :: { Lang.AbsParser.Exp }
Exp12
  : Exp12 '++' Exp13 { Lang.AbsParser.EAPPEND $1 $3 }
  | Exp12 '*' Exp13 { Lang.AbsParser.EMul $1 $3 }
  | Exp12 '/' Exp13 { Lang.AbsParser.EDiv $1 $3 }
  | Exp13 { $1 }

Exp11 :: { Lang.AbsParser.Exp }
Exp11
  : Exp11 '+' Exp12 { Lang.AbsParser.EAdd $1 $3 }
  | Exp11 '-' Exp12 { Lang.AbsParser.ESub $1 $3 }
  | Exp12 { $1 }

Exp9 :: { Lang.AbsParser.Exp }
Exp9
  : Exp9 '<' Exp10 { Lang.AbsParser.ELt $1 $3 }
  | Exp9 '>' Exp10 { Lang.AbsParser.EGt $1 $3 }
  | Exp9 '<=' Exp10 { Lang.AbsParser.ELEq $1 $3 }
  | Exp9 '>=' Exp10 { Lang.AbsParser.EGEq $1 $3 }
  | Exp10 { $1 }

Exp8 :: { Lang.AbsParser.Exp }
Exp8
  : Exp8 '==' Exp9 { Lang.AbsParser.EEq $1 $3 }
  | Exp8 '!=' Exp9 { Lang.AbsParser.ENEq $1 $3 }
  | Exp9 { $1 }

Exp4 :: { Lang.AbsParser.Exp }
Exp4 : Exp4 '&&' Exp5 { Lang.AbsParser.EAnd $1 $3 } | Exp5 { $1 }

Exp3 :: { Lang.AbsParser.Exp }
Exp3 : Exp3 '||' Exp4 { Lang.AbsParser.EOr $1 $3 } | Exp4 { $1 }

Exp1 :: { Lang.AbsParser.Exp }
Exp1
  : '\\' ListPIdent '->' Stmt1 { Lang.AbsParser.ELambda $2 $4 }
  | 'fun' ListPIdent '->' Stmt1 { Lang.AbsParser.ELambda $2 $4 }
  | Exp1 Exp2 { Lang.AbsParser.EApp $1 $2 }
  | Exp2 { $1 }

ListPIdent :: { [Lang.AbsParser.PIdent] }
ListPIdent : PIdent { (:[]) $1 } | PIdent ListPIdent { (:) $1 $2 }

TypeAnnotation :: { Lang.AbsParser.TypeAnnotation }
TypeAnnotation
  : '::' Type { Lang.AbsParser.TYPEANNOTATION $2 }
  | {- empty -} { Lang.AbsParser.TYPEANNOTATION_EMPTY }

Exp :: { Lang.AbsParser.Exp }
Exp : Exp1 { $1 }

Exp2 :: { Lang.AbsParser.Exp }
Exp2 : Exp3 { $1 }

Exp5 :: { Lang.AbsParser.Exp }
Exp5 : Exp6 { $1 }

Exp6 :: { Lang.AbsParser.Exp }
Exp6 : Exp7 { $1 }

Exp7 :: { Lang.AbsParser.Exp }
Exp7 : Exp8 { $1 }

Exp10 :: { Lang.AbsParser.Exp }
Exp10 : Exp11 { $1 }

Exp14 :: { Lang.AbsParser.Exp }
Exp14 : Exp15 { $1 }

ListExp :: { [Lang.AbsParser.Exp] }
ListExp
  : {- empty -} { [] }
  | Exp { (:[]) $1 }
  | Exp ',' ListExp { (:) $1 $3 }

ConstantType :: { Lang.AbsParser.ConstantType }
ConstantType
  : PInteger { Lang.AbsParser.INTEGER $1 }
  | String { Lang.AbsParser.STRING $1 }
  | Char { Lang.AbsParser.CHAR $1 }
  | Double { Lang.AbsParser.DOUBLE $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

